Spring IOC
----------
1. default-init-method what will do?
	Answer: If we define default-init-method, it will try to execute that init method before each bean initialization. That init method need to define inside of each bean class, but not necessary.
	
2. afterPropertiesSet() from InitializingBean interface and init-method in xml, which will call first?
	Answer: afterPropertiesSet() method will call first after that whatever we mentioned in init-method of that bean in context xml, that will execute. If we used interface and xml config in bean and init-method name same as afterPropertiesSet(). Then it will execute only once.
	
3. destroy() from DisposableBean interface and destroy-method in xml, which will call first?
	Answer: destroy() method will call first after that whatever we mentioned in destroy-method of that bean in context xml, that will execute. If we used interface and xml config in bean and destory-method name same as destroy(). Then it will execute only once.	

4. BeanPostProcessor and Ordered interface?
	Answer: BeanPostProcessor is used to callback before bean initialization and after initialization of every bean. We have to implement BeanPostProcessor interface and the implemented class need to be define in xml. If we define the implemented class in xml, spring will automatically identify that as post process bean.
		Ordered interface is used to order the one or more BeanPostProcessor in same context. It will implement getOrder() method to define the order.

5. Can we use BeanPostProcessor implemented class as normal bean?
	Answer: Yes, we can use as a normal bean class. But it is not recommended. As we are using only for post procees purpose. If we didn't define id or name for that bean, then we can't access through container.
	
6. When index is required in constructor-ref or property?
	Answer: If the constructor arguments are in same type or if we didn't define type then we have to go for that options.
	
7. Can we declare inner beans?
	Answer: Yes, we can define inner beans. Instead of defining ref arguments, we can define inner beans. But inner beans, we can't use it outside.
	
8. Can we use inner beans outisde by using Context.getBeans()?
	Answer: No, inner beans never called or used outisde.
	
9. What are the ways to do Dependency Injection in spring?
	Answer:
		1. Constructor Based
		2. Setter Based
		
10. What are the collections, we can use it in bean configuration?
	Answer:
		1. List
		2. Set
		3. Map
		4. props
		
11. What is value-type in list?
	Answer: value-type defining the data type of elements or values inside the list.
	
12. How to create a linked list in xml?
	Answer: Using java.util.LinkedList, we can create a linked list and assign to the property, where we required.
		<bean id="linkedList" class="java.util.LinkedList">
			<constructor-arg>
				<list>
					<value>India</value>
					<value>Sri Lanka</value>
					<value>Thailand</value>
				</list>
			</constructor-arg>
	   </bean>
	   
13. How to inject another bean inside list?
	Answer: Using below code we can inject another bean reference to list. But, the list should accept all objects.
		<list>
			..
			<ref bean="beanName"></ref>
		</list>
		
14. How to assign empty and null value in spring xml?
	Answer: We can use "" to assign empty value and we can use <null/> to assign null value to any element. See the below example.
		To assign Empty value:
		----------------------
		<bean id = "..." class = "exampleBean">
		   <property name = "email" value = ""/>
		</bean>
		
		To assign Null Value:
		-----------------------
		<bean id = "..." class = "exampleBean">
		   <property name = "email"><null/></property>
		</bean>
		
15. Autowire types in spring?
	Answer:
		1. no
		2. byName
		3. byType
		4. constructor
		5. default
		
16. Can we override autowiring?
	Answer: Yes, by defining constructor or setter based, we can override the autowire.
	
17. Can we autowire primitive data types?
	Answer: No, primitive data types and strings, can't do autowire.
	
18. What are the scope types available in Spring?
	Answer:
		1. singleton
		2. prototype
		3. request
		4. session
		5. global-session
		
19. How you create new instance, whenever the bean is calling?
	Answer: We can set bean scope as prototype. Then it will create a new instance, whenever we are calling.
			In XML => scope="prototype"
			In Annoation => @Scope("prototype")

20. What are the EventHandlers available in Spring Context?
	Answer:
		1. ContextRefreshedEvent
		2. ContextStartedEvent
		3. ContextStoppedEvent
		4. ContextClosedEvent
		5. RequestHandledEvent

21. How many types of RetentionPolicy?
	Answer:
		1. SOURCE
		2. CLASS
		3. RUNTIME
		
22. What is @Target?
	Answer: @Target will define the target element.
	
23. What are the element types are available in @Target?
	Answer:
		ElementType.ANNOTATION_TYPE
		ElementType.CONSTRUCTOR
		ElementType.FIELD
		ElementType.LOCAL_VARIABLE
		ElementType.METHOD
		ElementType.PACKAGE
		ElementType.PARAMETER
		ElementType.TYPE -> Class, Interface, enum and annotation
		
24. Give some example usage of ANNOTATION_TYPE in @Target?
	Answer: Answer is in the question itself. We are using @Target and @Retention only for custom annotation place.
	
25. How annotation used in Java super class can be inherited to sub classes?
	Answer: Using @Inherited, we can inherit the annoations used in super class to sub class. We can this annotation only on Custom Annoation. Not in class directly.
	
26. How to create custom annotation?
	Answer: Using @Interface , we can create custom annotation.
	
27. What are the ways to use multiple configuration class?
	Answer:
		1. If all the configuration is inside same package, then we can mention base package, it will take all configuration
		2. If the configuration class in different package, 
			1. We can define all the packages in @ComponentScan(basePackages="{}")
			2. We can import the config class in main config class using @Import annotation

28. How to avoid component scan for particular sub package in xml and annotation?
	Answer:
		1. XML - <context:exclude-filter type="annotation" expression="com.demo.ignore"/>
		2. Annoation - @ComponentScan(basePackages = "com.concretepage",
			includeFilters = @Filter(type = FilterType.REGEX, pattern="com.concretepage.*.*Util"),
			excludeFilters = @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = IUserService.class)) 
	
29. What are the  Component Scan Filter Types?
	Answer:
		Find the component filter types. 
		
		ANNOTATION: Component scan of classes can be included and excluded by configuring annotation name applied at class level. 

		ASSIGNABLE_TYPE: Using interface name or class name that has been implemented or extended by the classes, we can include and exclude classes in component scanning. 

		ASPECTJ: Using aspect expression targeting classes names, it can be included and excluded in component scanning. 

		REGEX: Using regex expression targeting classes names, it can be included and excluded in component scanning. 

		custom: We can also create custom filter type by implementing org.springframework.core.type.TypeFilter.
		
30. What is the difference between @Autowired and @Autowired()?
	Answer: No difference both are same.
	
31. How to load property file into class?
	Answer: Using @PropertySource(classpath:test.properties), we can load property file into class.
	
32. How to use the value from properties file after its loaded?
	Answer: Using ${varname}, we can get the value from properties file.

33. Explain Bean lifecycle in Spring framework?
	Answer:
	Following is sequence of a bean lifecycle in Spring:

	Instantiate: First the spring container finds the bean’s definition from the XML file and instantiates the bean.

	Populate properties: Using the dependency injection, spring populates all of the properties as specified in the bean definition.

	Set Bean Name: If the bean implements BeanNameAware interface, spring passes the bean’s id to setBeanName() method.

	Set Bean factory: If Bean implements BeanFactoryAware interface, spring passes the beanfactory to setBeanFactory() method.

	Pre Initialization: Also called post process of bean. If there are any bean BeanPostProcessors associated with the bean, Spring calls postProcesserBeforeInitialization() method.

	Initialize beans: If the bean implements IntializingBean,its afterPropertySet() method is called. If the bean has init method declaration, the specified initialization method is called.

	Post Initialization: – If there are any BeanPostProcessors associated with the bean, their postProcessAfterInitialization() methods will be called.

	Ready to use: Now the bean is ready to use by the application

	Destroy: If the bean implements DisposableBean , it will call the destroy() method
	
	
Spring - AOP
------------
1. What is AOP?
	Answer: Aspect Oriented Programming. Aspect means class,type, method, constructor and so on.
	
2. Can we use Spring AOP in xml based context?
	Answer: Yes, ofcourse , we can use Spring AOP in xml based context. But, we can't directly use AspectJ in xml based contexr, since it is annotation based.
	
3. Which is best Spring AOP or AspectJ AOP?
	Answer: Spring AOP is best when you are going with Spring framework. Any how Spring AOP internally using AspectJ AOP only.
	
4. What is the difference between Spring AOP and AspectJ AOP?
	Answer:
		Spring AOP									AspectJ AOP
		-------------------------------------		----------------------------------------------------
		1. We can use it in XML	Based context		We can't use it in xml based context, only annotation
			and annotation based also.
		
		2. No need to do any extra configuration	If you want to use AspectJ directly in spring framework, then we need to some more configurations.
			while doing with spring framework
			
		3. Limited features							More features compared to Spring AOP
		
		4. Internally using AspectJ AOP				AspectJ is stand alone.
		
		5. We can use it only on methods			We can use it for other types. Ex: constructor
		
5. Which tag will use it to define aspects in XML?
	Answer: <aop:config></aop:config> will be used to define all aspects inside it. To use this tag, we need to import this context http://www.springframework.org/schema/aop in xml.
	
6. What is Advice and types of advice in AOP?
	Answer: AOP advice is kind of an interceptor around the joint point. Here joint point means method execution.
			Types:
			------
			Before advice: Advice that executes before a join point, but which does not have the ability to prevent execution flow proceeding to the join point (unless it throws an exception).

			After returning advice: Advice to be executed after a join point completes normally: for example, if a method returns without throwing an exception.

			After throwing advice: Advice to be executed if a method exits by throwing an exception.

			After (finally) advice: Advice to be executed regardless of the means by which a join point exits (normal or exceptional return).

			Around advice: Advice that surrounds a join point such as a method invocation. This is the most powerful kind of advice. Around advice can perform custom behavior before and after the method invocation. It is also responsible for choosing whether to proceed to the join point or to shortcut the advised method execution by returning its own return value or throwing an exception.
			
7. What is pointcut?
	Answer: Pointcut is a expression will intimate where to check the methods.
	
8. Type of pointcut designators?
	Answer:
		1. execution
		2. within
		3. this
		4. target
		5. args
		6. bean
		7. @target
		8. @args
		9. @within
		10. @annotation
	
9. How to define pointcut only for inside packages not in sub package classes method execution?
	Answer: execution(* com.xyz.service.*.*(..))
	
10. How to define the order of advice execution?
	Answer: Either we can use @Order annotation or we can implement the Ordered interface. Which is the lowest number will execute first.
	
11. If advice method in different aspect class, then we can use @Order or Ordered interface. What we can do if advice methods are in same Aspect class?
	Answer: If advice methods are in same class, then based on method name, it will execute. For example method names are log() and log1(). Then log() will execute first, then log1() will execute.
	
12. Whether aspect will be create new instance or single instance proxy?
	Answer: Based on bean definition, it will create single or multiple instances will be created.
	For example: Target class is prototype and Aspect class in singleton. Then all target class objects, it will give only one instance of aspect.
	
13. How enable AspectJ in spring using annotation and xml?
	Answer:
		XML -> <aop:aspectj-autoproxy/>
		Annotation -> @EnableAspectJAutoProxy
		
14. Advising aspects with other aspects?
	Answer: In Spring AOP, it is not possible to have aspects themselves be the target of advice from other aspects. The @Aspect annotation on a class marks it as an aspect, and hence excludes it from auto-proxying. 
	
15. In target class local or internal calls to methods from another method, will go through by proxy class or not?
	Answer: No. A call from a method in a target to another method in the target does not get intercepted by the proxy. Try to remember the proxy pattern.
	
16. How you call through the proxy class, while calling internal method from another internal method?
	Answer: Using AopContext.currentProxy(), we can get a proxy class of current class. With that we can call the method, which we want to call. 
	Of course, take heed that this tightly couples your core business concern to AOP – something you are trying to avoid with AOP to begin with.  So it may be better to refactor the code such that internal calls are not required when you need advice to fire on all methods.
	
17. How to access the AopContext in outside?
	Answer: Using @EnableAspectJAutoProxy(exposeProxy=true), we can make AopContext to be available in outside.
	
18. How to enable CGLIB proxies instead of using JDK dynamic proxies?
	Answer: Usinng @EnableAspectJAutoProxy(proxyTargetClass=true), we can change the proxy class library to CGLIB proxy library.
	
19. What is @Configurable?
	Answer: There is no way to inject dependencies into a bean created with the new operator. For that we can use @Configurable from AspectJ.
	
